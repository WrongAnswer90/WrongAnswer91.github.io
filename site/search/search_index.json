{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u8fd9\u91cc\u662f WA90 \u7684\u4ee3\u7801\u4ed3\u5e93\uff0c\u90e8\u5206\u6a21\u677f\u9700\u8981\u642d\u914d \u7f3a\u7701\u6e90 \u4f7f\u7528 QQ\uff1a2609493041 \u6b22\u8fce\u8054\u7cfb\u3002","title":"Home"},{"location":"Math/Poly/FWT/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 inline void AND ( vector < int >& ve , int opt = 1 ) { int n = ve . size (); if ( opt == 1 ) for ( int k = 2 ; k <= n ; k <<= 1 ) { for ( int i = 0 ; i < n ; i += k ) { for ( int j = i ; j < i + ( k >> 1 ); ++ j ) Madd ( ve [ j ], ve [ j + ( k >> 1 )]); } } else for ( int k = 2 ; k <= n ; k <<= 1 ) { for ( int i = 0 ; i < n ; i += k ) { for ( int j = i ; j < i + ( k >> 1 ); ++ j ) Mdel ( ve [ j ], ve [ j + ( k >> 1 )]); } } } inline void OR ( vector < int >& ve , int opt = 1 ) { int n = ve . size (); if ( opt == 1 ) for ( int k = 2 ; k <= n ; k <<= 1 ) { for ( int i = 0 ; i < n ; i += k ) { for ( int j = i ; j < i + ( k >> 1 ); ++ j ) Madd ( ve [ j + ( k >> 1 )], ve [ j ]); } } else for ( int k = 2 ; k <= n ; k <<= 1 ) { for ( int i = 0 ; i < n ; i += k ) { for ( int j = i ; j < i + ( k >> 1 ); ++ j ) Mdel ( ve [ j + ( k >> 1 )], ve [ j ]); } } } inline void XOR ( vector < int >& ve , int opt = 1 ) { int n = ve . size (); for ( int k = 2 ; k <= n ; k <<= 1 ) { for ( int i = 0 ; i < n ; i += k ) { for ( int j = i ; j < i + ( k >> 1 ); ++ j ) { Madd ( ve [ j ], ve [ j + ( k >> 1 )]); ve [ j + ( k >> 1 )] = Cdel ( ve [ j ], ve [ j + ( k >> 1 )], ve [ j + ( k >> 1 )]); } } } int tmp = power ( inv2 , __lg ( n )); if ( opt == -1 ) for ( int i = 0 ; i < n ; ++ i ) Mmul ( ve [ i ], tmp ); } inline vi MUL ( vi a , vi b ) { int N = a . size (), n = __lg ( N ); static vi c , A [ 21 ], B [ 21 ], C [ 21 ]; c . resize ( N ); for ( int i = 0 ; i <= n ; ++ i ) { A [ i ]. clear (), B [ i ]. clear (); A [ i ]. resize ( N ), B [ i ]. resize ( N ), C [ i ]. resize ( N ); } for ( int i = 0 ; i < N ; ++ i ) A [ __builtin_popcount ( i )][ i ] = a [ i ]; for ( int i = 0 ; i < N ; ++ i ) B [ __builtin_popcount ( i )][ i ] = b [ i ]; for ( int i = 0 ; i <= n ; ++ i ) OR ( A [ i ]), OR ( B [ i ]); for ( int i = 0 ; i <= n ; ++ i ) { for ( int j = 0 ; j + i <= n ; ++ j ) { for ( int k = 0 ; k < N ; ++ k ) Madd ( C [ i + j ][ k ], Cmul ( A [ i ][ k ], B [ j ][ k ])); } } for ( int i = 0 ; i <= n ; ++ i ) OR ( C [ i ], -1 ); for ( int i = 0 ; i < N ; ++ i ) c [ i ] = C [ __builtin_popcount ( i )][ i ]; return c ; }","title":"\u96c6\u5408\u5e42\u7ea7\u6570"},{"location":"Math/Poly/interpolation/","text":"\u6c42\u591a\u9879\u5f0f\u7cfb\u6570\u8868\u793a\u6cd5\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int n , m , ans , x [ 2010 ], y [ 2010 ], d [ 2010 ], a [ 2010 ], b [ 2010 ]; inline void mian () { read ( n , m ), a [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { read ( x [ i ], y [ i ]); for ( int j = i ; j >= 1 ; -- j ) a [ j ] = Cdel ( a [ j -1 ], Cmul ( x [ i ], a [ j ])); Mmul ( a [ 0 ], MOD - x [ i ]); } for ( int i = 1 , v ; i <= n ; ++ i ) { int c = power ( MOD - x [ i ], MOD -2 ); v = 1 , b [ 0 ] = Cmul ( a [ 0 ], c ); for ( int j = 1 ; j < n ; ++ j ) b [ j ] = Cmul ( Cdel ( a [ j ], b [ j -1 ]), c ); for ( int j = 1 ; j <= n ; ++ j ) if ( i != j ) Mmul ( v , Cdel ( x [ i ], x [ j ])); v = Cmul ( y [ i ], power ( v , MOD -2 )); for ( int j = 0 ; j < n ; ++ j ) Madd ( d [ j ], Cmul ( v , b [ j ])); } for ( int j = 0 ; j < n ; ++ j ) Madd ( ans , Cmul ( power ( m , j ), d [ j ])); write ( ans ); } \u6c42\u70b9\u503c\uff1a 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int n , k , ans , x [ 2001 ], y [ 2001 ]; inline void mian () { read ( n , k ); for ( int i = 1 ; i <= n ; ++ i ) read ( x [ i ], y [ i ]); for ( int i = 1 ; i <= n ; ++ i ) { int up = y [ i ], down = 1 ; for ( int j = 1 ; j <= n ; ++ j ) { if ( i == j ) continue ; Mmul ( up , k - x [ j ]), Mmul ( down , x [ i ] - x [ j ]); } Madd ( ans , Cmul ( up , power ( down , MOD -2 ))); } write ( ans ); }","title":"\u62c9\u683c\u6717\u65e5\u63d2\u503c"},{"location":"Math/Poly/poly/","text":"\u611f\u89c9\u5e38\u6570\u8fd8\u7b97\u6bd4\u8f83\u4f18\u79c0 QwQ\u3002\u4ee5\u4e0b\u6570\u636e\u8303\u56f4\u9664\u4e86 FFT \u5747\u662f \\(10^5\\) \u3002 FFT( \\(10^6\\) ): \\(270\\text{ms}\\) \u6c42\u9006: \\(33\\text{ms}\\) \u5f00\u6839: \\(53\\text{ms}\\) \u5bf9\u6570\u51fd\u6570: \\(50\\text{ms}\\) \u6307\u6570\u51fd\u6570: \\(175\\text{ms}\\) \uff08\u592a\u62c9\u4e86\uff09 \u9664\u6cd5\uff08\u53d6\u6a21\uff09: \\(50\\text{ms}\\) \u5e42\u51fd\u6570: \\(320\\text{ms}\\) \uff08\u592a\u62c9\u4e86\uff09 \u6ce8\u610f\u66f4\u6539 MAXN\u3002\u4f7f\u7528\u524d\u8981\u8c03\u7528 init() \u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 namespace Poly { const int MAXN = 200000 ; int Shape , Invn [ MAXN + 10 ], R [ MAXN * 4 + 10 ], Prt [ MAXN * 4 ]; inline void init () { Invn [ 0 ] = 1 ; for ( int i = 1 ; i <= MAXN ; ++ i ) Invn [ i ] = Cmul ( Invn [ i -1 ], i ); int tmp = power ( Invn [ MAXN ], MOD -2 ); for ( int i = MAXN ; i >= 1 ; -- i ) Invn [ i ] = Cmul ( tmp , Invn [ i -1 ]), Mmul ( tmp , i ); } inline int inv ( int x ){ return x <= MAXN ? Invn [ x ] : power ( x , MOD -2 );} inline void NTT ( vi & A , int n , int opt ) { static ull B [ MAXN * 4 + 10 ], iv = power ( n , MOD -2 ); A . resize ( n ); for ( int i = 0 ; i < n ; ++ i ) B [ i ] = A [ R [ i ]]; for ( int mid = 1 ; mid < n ; mid <<= 1 ) { for ( int j = 0 ; j < n ; j += mid << 1 ) { for ( int k = j ; k < j + mid ; ++ k ) { ull x = B [ k ], y = Prt [ mid + k - j ] * B [ k + mid ] % MOD ; B [ k ] = x + y , B [ k + mid ] = x + MOD - y ; } } } if ( opt ) for ( int i = 0 ; i < n ; ++ i ) A [ i ] = B [ i ] % MOD ; else { reverse ( B + 1 , B + n ); for ( int i = 0 ; i < n ; ++ i ) A [ i ] = Cmul ( B [ i ] % MOD , iv );} } inline void init ( int lim ) { if ( lim == Shape ) return ; int n = lim / 2 ; Shape = lim ; for ( int i = 0 ; i < lim ; ++ i ) R [ i ] = ( R [ i >> 1 ] >> 1 ) | (( i & 1 ) ? n : 0 ); for ( int i = 1 ; i < lim ; i <<= 1 ) { int wm = power ( Root ,( MOD -1 ) / ( i << 1 )); Prt [ i ] = 1 ; for ( int j = 1 ; j < i ; ++ j ) Prt [ i + j ] = Cmul ( Prt [ i + j -1 ], wm ); } } inline vi del ( vi A , vi B , int N = -1 ) { if ( ~ N ) A . resize ( N + 1 ), B . resize ( N + 1 ); int n = A . size () -1 ; for ( int i = 0 ; i <= n ; ++ i ) Mdel ( A [ i ], B [ i ]); return A ; } inline vi add ( vi A , vi B , int N = -1 ) { if ( ~ N ) A . resize ( N + 1 ), B . resize ( N + 1 ); int n = A . size () -1 ; for ( int i = 0 ; i <= n ; ++ i ) Madd ( A [ i ], B [ i ]); return A ; } inline vi mul ( vi A , int k , int N = -1 ) { if ( ~ N ) A . resize ( N + 1 ); int n = A . size () -1 ; for ( int i = 0 ; i <= n ; ++ i ) Mmul ( A [ i ], k ); return A ; } inline vi inte ( vi A , int N = -1 ) { if ( ~ N ) A . resize ( N + 1 ); int n = A . size (); A . resize ( n + 1 ); for ( int i = n ; i > 0 ; -- i ) A [ i ] = Cmul ( A [ i -1 ], inv ( i )); return A [ 0 ] = 0 , A ; } inline vi der ( vi A , int N = -1 ) { if ( ~ N ) A . resize ( N + 1 ); int n = A . size () -2 ; for ( int i = 0 ; i <= n ; ++ i ) A [ i ] = Cmul ( A [ i + 1 ], i + 1 ); return A . resize ( n + 1 ), A ; } inline vi FFT ( vi A , vi B , int N1 = -1 , int N2 = -1 ) { if ( N1 != -1 ) A . resize ( N1 + 1 ); if ( N2 != -1 ) B . resize ( N2 + 1 ); int n = A . size () -1 , m = B . size () -1 , N = 1 , len = 0 ; while ( N <= n + m ) N <<= 1 , ++ len ; init ( N ), NTT ( A , N , 1 ), NTT ( B , N , 1 ); for ( int i = 0 ; i < N ; ++ i ) A [ i ] = Cmul ( A [ i ], B [ i ]); return NTT ( A , N , 0 ), A . resize ( n + m + 1 ), A ; } inline vi inv ( vi A , int N = -1 ) { if ( N != -1 ) A . resize ( N + 1 ); vi B = {( int ) power ( A [ 0 ], MOD -2 )}; int n = A . size () -1 , nn = n ; for ( n = 1 ; n <= nn + 1 ; n <<= 1 ) { vi TB = B , C ( n * 2 ); init ( n << 1 ); copy ( A . begin (), A . begin () + min ( nn + 1 , 2 * n ), C . begin ()); NTT ( C , n << 1 , 1 ), NTT ( B , n << 1 , 1 ); for ( int i = 0 ; i < ( n << 1 ); ++ i ) C [ i ] = 1l l * C [ i ] * B [ i ] % MOD ; NTT ( C , n << 1 , 0 ); C . resize ( n << 1 ); fill ( C . begin (), C . begin () + n , 0 ), NTT ( C , n << 1 , 1 ); for ( int i = 0 ; i < ( n << 1 ); ++ i ) B [ i ] = 1l l * B [ i ] * ( MOD - C [ i ]) % MOD ; NTT ( B , n << 1 , 0 ); B . resize ( n << 1 ), move ( TB . begin (), TB . end (), B . begin ()); } return B . resize ( nn + 1 ), B ; } inline vi ln ( vi A , int N = -1 ){ return inte ( FFT ( der ( A , N ), inv ( A , N )));} inline vi exp ( vi A , int N = -1 ) { if ( ~ N ) A . resize ( N + 1 ); int m = A . size () -1 ; static vi B , C ; B . clear (), C . clear (), B . eb ( 1 ); for ( int n = 2 ; n <= m ; n <<= 1 ) B . resize ( n + 1 ), C = del ( A , ln ( B ), n ), Madd ( C [ 0 ], 1 ), B = FFT ( B , C , n , n ); C = del ( A , ln ( B ), m ), Madd ( C [ 0 ], 1 ); B . resize ( m + 1 ), C . resize ( m + 1 ); B = FFT ( B , C , m , m ), B . resize ( m + 1 ); return B ; } inline vi div ( vi A , vi B , int N1 = -1 , int N2 = -1 ) { if ( ~ N1 ) A . resize ( N1 + 1 ); if ( ~ N2 ) B . resize ( N2 + 1 ); int n = A . size () -1 , m = B . size () -1 ; reverse ( A . begin (), A . end ()), reverse ( B . begin (), B . end ()); A = FFT ( A , inv ( B , n - m + 1 )), A . resize ( n - m + 1 ), reverse ( A . begin (), A . end ()); return A ; } }","title":"\u591a\u9879\u5f0f"},{"location":"Math/number%20theory/BSGS/","text":"BSGS \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 inline int power ( int a , int b , int p ) { int ans = 1 ; for (; b ; a = a * a % p , b >>= 1 ) if ( b & 1 ) ans = ans * a % p ; return ans ; } inline int BSGS ( int a , int b , int p ) { int t = sqrt ( p ) + 1 ; unordered_map < int , int > mp ; mp . clear (), b %= p ; for ( int j = 0 , now = b ; j < t ; now = now * a % p , ++ j ) mp [ now ] = j ; a = power ( a , t , p ); if ( ! a ) return b ? -1 : 1 ; for ( int i = 0 , now = 1 ; i <= t ; now = now * a % p , ++ i ) { int j = mp . find ( now ) == mp . end () ? -1 : mp [ now ]; if ( j >= 0 && i * t - j >= 0 ) return i * t - j ; } return -1 ; } exBSGS \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 inline int power ( int a , int b , int p ) { int ans = 1 ; for (; b ; a = a * a % p , b >>= 1 ) if ( b & 1 ) ans = ans * a % p ; return ans ; } inline int BSGS ( int a , int b , int p ) { int t = sqrt ( p ) + 1 ; unordered_map < int , int > mp ; mp . clear (), b %= p ; for ( int j = 0 , now = b ; j < t ; now = now * a % p , ++ j ) mp [ now ] = j ; a = power ( a , t , p ); if ( ! a ) return b ? -1 : 1 ; for ( int i = 0 , now = 1 ; i <= t ; now = now * a % p , ++ i ) { int j = mp . find ( now ) == mp . end () ? -1 : mp [ now ]; if ( j >= 0 && i * t - j >= 0 ) return i * t - j ; } return -1 ; } void exgcd ( int a , int b , int & x , int & y ) { if ( ! b ) return x = 1 , y = 0 , void (); exgcd ( b , a % b , x , y ); int z = x ; x = y , y = z - x * ( a / b ); } int gcd ( int a , int b ){ return b ? gcd ( b , a % b ) : a ;} inline int inv ( int b , int p ){ int x , y ; exgcd ( b , p , x , y ), x = ( x % p + p ) % p ; return x ;} inline int exBSGS ( int a , int b , int p ) { b %= p ; if ( b == 1 || p == 1 ) return 0 ; int na = 1 , k = 0 , g = gcd ( a , p ); while ( g > 1 ) { if ( b % g != 0 ) return -1 ; ++ k , b /= g , p /= g , na = na * ( a / g ) % p , g = gcd ( a , p ); if ( na == b ) return k ; } int f = BSGS ( a , b * inv ( na , p ) % p , p ); if ( f == -1 ) return -1 ; return f + k ; }","title":"BSGS"},{"location":"Math/number%20theory/BSGS/#bsgs","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 inline int power ( int a , int b , int p ) { int ans = 1 ; for (; b ; a = a * a % p , b >>= 1 ) if ( b & 1 ) ans = ans * a % p ; return ans ; } inline int BSGS ( int a , int b , int p ) { int t = sqrt ( p ) + 1 ; unordered_map < int , int > mp ; mp . clear (), b %= p ; for ( int j = 0 , now = b ; j < t ; now = now * a % p , ++ j ) mp [ now ] = j ; a = power ( a , t , p ); if ( ! a ) return b ? -1 : 1 ; for ( int i = 0 , now = 1 ; i <= t ; now = now * a % p , ++ i ) { int j = mp . find ( now ) == mp . end () ? -1 : mp [ now ]; if ( j >= 0 && i * t - j >= 0 ) return i * t - j ; } return -1 ; }","title":"BSGS"},{"location":"Math/number%20theory/BSGS/#exbsgs","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 inline int power ( int a , int b , int p ) { int ans = 1 ; for (; b ; a = a * a % p , b >>= 1 ) if ( b & 1 ) ans = ans * a % p ; return ans ; } inline int BSGS ( int a , int b , int p ) { int t = sqrt ( p ) + 1 ; unordered_map < int , int > mp ; mp . clear (), b %= p ; for ( int j = 0 , now = b ; j < t ; now = now * a % p , ++ j ) mp [ now ] = j ; a = power ( a , t , p ); if ( ! a ) return b ? -1 : 1 ; for ( int i = 0 , now = 1 ; i <= t ; now = now * a % p , ++ i ) { int j = mp . find ( now ) == mp . end () ? -1 : mp [ now ]; if ( j >= 0 && i * t - j >= 0 ) return i * t - j ; } return -1 ; } void exgcd ( int a , int b , int & x , int & y ) { if ( ! b ) return x = 1 , y = 0 , void (); exgcd ( b , a % b , x , y ); int z = x ; x = y , y = z - x * ( a / b ); } int gcd ( int a , int b ){ return b ? gcd ( b , a % b ) : a ;} inline int inv ( int b , int p ){ int x , y ; exgcd ( b , p , x , y ), x = ( x % p + p ) % p ; return x ;} inline int exBSGS ( int a , int b , int p ) { b %= p ; if ( b == 1 || p == 1 ) return 0 ; int na = 1 , k = 0 , g = gcd ( a , p ); while ( g > 1 ) { if ( b % g != 0 ) return -1 ; ++ k , b /= g , p /= g , na = na * ( a / g ) % p , g = gcd ( a , p ); if ( na == b ) return k ; } int f = BSGS ( a , b * inv ( na , p ) % p , p ); if ( f == -1 ) return -1 ; return f + k ; }","title":"exBSGS"},{"location":"Math/number%20theory/CRT/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 int exgcd ( int a , int b , int & x , int & y ) { if ( ! b ) return x = 1 , y = 0 , a ; int d = exgcd ( b , a % b , x , y ); int z = x ; x = y , y = z - x * ( a / b ); return d ; } int gcd ( int a , int b ){ return b ? gcd ( b , a % b ) : a ;} int m [ 100010 ], a [ 100010 ], n , M = 1 , x0 = 0 , MM , b , k , x , y ; inline int calc () { for ( int i = 1 ; i <= n ; ++ i ) { b = a [ i ] - x0 ; int d = exgcd ( M , m [ i ], k , y ); if ( b % d != 0 ){ write ( 114514 ); return ;} k = ( k * b / d % ( m [ i ] / d ) + m [ i ] / d ) % ( m [ i ] / d ), MM = M / gcd ( M , m [ i ]) * m [ i ]; x0 = (( x0 + k * M ) % MM + MM ) % MM , M = MM ; } return x0 ; }","title":"\u4e2d\u56fd\u5269\u4f59\u5b9a\u7406(exCRT)"},{"location":"Math/number%20theory/gcd/","text":"Binary GCD \u00b6 1 2 3 4 5 6 7 inline int gcd ( int a , int b ) { int az = __builtin_ctz ( a ), bz = __builtin_ctz ( b ); int z = min ( az , bz ), tmp ; b >>= bz ; while ( a ) a >>= az , tmp = a - b , az = __builtin_ctz ( tmp ), b = min ( a , b ), a = abs ( tmp ); return b << z ; } \u503c\u57df\u9884\u5904\u7406 GCD \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 bitset < 1000010 > v ; int cnt , ans , f [ 1000010 ][ 3 ], c [ 1010 ][ 1010 ], pr [ 300010 ]; inline int gcd ( int x , int y ) { int ans = 1 ; for ( int i = 0 ; i < 3 ; ++ i ) { int tmp = f [ x ][ i ] > 1000 ? y % f [ x ][ i ] ? 1 : f [ x ][ i ] : c [ f [ x ][ i ]][ y % f [ x ][ i ]]; y /= tmp , ans *= tmp ; } return ans ; } inline void mian () { f [ 1 ][ 0 ] = f [ 1 ][ 1 ] = f [ 1 ][ 2 ] = 1 ; for ( int i = 2 ; i <= 1000000 ; ++ i ) { if ( ! v [ i ]) pr [ ++ cnt ] = i , f [ i ][ 0 ] = f [ i ][ 1 ] = 1 , f [ i ][ 2 ] = i ; for ( int j = 1 ; j <= cnt && i * pr [ j ] <= 1000000 ; ++ j ) { v [ i * pr [ j ]] = 1 ; f [ i * pr [ j ]][ 0 ] = f [ i ][ 0 ] * pr [ j ]; f [ i * pr [ j ]][ 1 ] = f [ i ][ 1 ]; f [ i * pr [ j ]][ 2 ] = f [ i ][ 2 ]; sort ( f [ i * pr [ j ]], f [ i * pr [ j ]] + 3 ); if ( i % pr [ j ] == 0 ) break ; } } for ( int i = 1 ; i <= 1000 ; ++ i ) c [ i ][ 0 ] = c [ 0 ][ i ] = i ; for ( int i = 1 ; i <= 1000 ; ++ i ) for ( int j = 1 ; j <= i ; ++ j ) c [ i ][ j ] = c [ j ][ i ] = c [ j ][ i % j ]; }","title":"\u6700\u5927\u516c\u7ea6\u6570(gcd)"},{"location":"Math/number%20theory/gcd/#binary-gcd","text":"1 2 3 4 5 6 7 inline int gcd ( int a , int b ) { int az = __builtin_ctz ( a ), bz = __builtin_ctz ( b ); int z = min ( az , bz ), tmp ; b >>= bz ; while ( a ) a >>= az , tmp = a - b , az = __builtin_ctz ( tmp ), b = min ( a , b ), a = abs ( tmp ); return b << z ; }","title":"Binary GCD"},{"location":"Math/number%20theory/gcd/#gcd","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 bitset < 1000010 > v ; int cnt , ans , f [ 1000010 ][ 3 ], c [ 1010 ][ 1010 ], pr [ 300010 ]; inline int gcd ( int x , int y ) { int ans = 1 ; for ( int i = 0 ; i < 3 ; ++ i ) { int tmp = f [ x ][ i ] > 1000 ? y % f [ x ][ i ] ? 1 : f [ x ][ i ] : c [ f [ x ][ i ]][ y % f [ x ][ i ]]; y /= tmp , ans *= tmp ; } return ans ; } inline void mian () { f [ 1 ][ 0 ] = f [ 1 ][ 1 ] = f [ 1 ][ 2 ] = 1 ; for ( int i = 2 ; i <= 1000000 ; ++ i ) { if ( ! v [ i ]) pr [ ++ cnt ] = i , f [ i ][ 0 ] = f [ i ][ 1 ] = 1 , f [ i ][ 2 ] = i ; for ( int j = 1 ; j <= cnt && i * pr [ j ] <= 1000000 ; ++ j ) { v [ i * pr [ j ]] = 1 ; f [ i * pr [ j ]][ 0 ] = f [ i ][ 0 ] * pr [ j ]; f [ i * pr [ j ]][ 1 ] = f [ i ][ 1 ]; f [ i * pr [ j ]][ 2 ] = f [ i ][ 2 ]; sort ( f [ i * pr [ j ]], f [ i * pr [ j ]] + 3 ); if ( i % pr [ j ] == 0 ) break ; } } for ( int i = 1 ; i <= 1000 ; ++ i ) c [ i ][ 0 ] = c [ 0 ][ i ] = i ; for ( int i = 1 ; i <= 1000 ; ++ i ) for ( int j = 1 ; j <= i ; ++ j ) c [ i ][ j ] = c [ j ][ i ] = c [ j ][ i % j ]; }","title":"\u503c\u57df\u9884\u5904\u7406 GCD"},{"location":"Math/number%20theory/genshin/","text":"\u6ce8\u610f\u5148\u8c03\u7528 sieve() \u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 int T , n , d , m , cnt , pr [ 100010 ]; bitset < 2000010 > v ; vector < int > ve , ans ; int gcd ( int x , int y ){ return y ? gcd ( y , x % y ) : x ;} inline int power ( int x , int y , int z ) { int s = 1 ; for (; y ; y >>= 1 , x = 1l l * x * x % z ) if ( y & 1 ) s = 1l l * s * x % z ; return s ; } inline int phi ( int x ) { int y = x ; for ( int i = 2 ; i * i <= x ; ++ i ) { if ( x % i == 0 ) { y = y / i * ( i -1 ); while ( x % i == 0 ) x /= i ; } } if ( x != 1 ) y = y / x * ( x -1 ); return y ; } inline void sieve () { for ( int i = 2 ; i <= 1000000 ; ++ i ) { if ( ! v [ i ]) pr [ ++ cnt ] = i ; for ( int j = 1 ; j <= cnt && i * pr [ j ] <= 1000000 ; ++ j ) { v [ i * pr [ j ]] = 1 ; if ( i % pr [ j ] == 0 ) break ; } } v . reset (), v [ 2 ] = v [ 4 ] = 1 ; for ( int i = 2 ; i <= cnt ; ++ i ) { for ( ll j = pr [ i ]; j <= 1000000 ; j *= pr [ i ]) v [ j ] = 1 , v [ 2 * j ] = 1 ; } } inline vi calc ( int n ) { read ( n , d ), m = phi ( n ), ans . clear (), ve . clear (); int mm = m , g = 1 ; if ( ! v [ n ]) return ans ; for ( int i = 2 ; i * i <= m ; ++ i ) if ( m % i == 0 ){ ve . eb ( i ); while ( m % i == 0 ) m /= i ;} if ( m != 1 ) ve . eb ( m ); for (; g < n ; ++ g ) { if ( gcd ( g , n ) != 1 ) continue ; int fl = 1 ; for ( auto p : ve ) if ( power ( g , mm / p , n ) == 1 ){ fl = 0 ; break ;} if ( fl ) break ; } for ( int i = 1 , nw = g ; i <= mm ; ++ i , nw = 1l l * nw * g % n ) if ( gcd ( i , mm ) == 1 ) ans . eb ( nw ); return ans ; }","title":"\u539f\u6839"},{"location":"Math/number%20theory/millerrabin/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 inline bool chk ( int n ) { if ( n < 3 || n % 2 == 0 ) return n == 2 ; int u = n -1 , t = 0 ; while ( u % 2 == 0 ) u /= 2 , ++ t ; for ( int i = 0 , s , a , v ; i < 8 ; ++ i ) { a = rd ( 2 , n -1 ), v = power ( a , u , n ); if ( v == 1 ) continue ; for ( s = 0 ; s < t ; ++ s ) { if ( v == n -1 ) break ; v = mul ( v , v , n ); } if ( s == t ) return 0 ; } return 1 ; }","title":"Miller-Rabin"},{"location":"Math/number%20theory/oper/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 int cnt , n , pr [ 2000010 ]; ui a [ 20000010 ], ans ; bitset < 20000010 > v ; inline void init () { for ( int i = 2 ; i <= 20000000 ; ++ i ) { if ( ! v [ i ]) pr [ ++ cnt ] = i ; for ( int j = 1 ; j <= cnt && i * pr [ j ] <= 20000000 ; ++ j ) { v [ i * pr [ j ]] = 1 ; if ( i % pr [ j ] == 0 ) break ; } } } inline void dirichlet () { for ( int i = 1 ; i <= cnt ; ++ i ) { for ( int j = 1 ; j * pr [ i ] <= 20000000 ; ++ j ) Madd ( a [ j * pr [ i ]], a [ j ]); } } inline void modius () { for ( int i = 1 ; i <= n ; ++ i ) { for ( int j = i + i ; j <= n ; j += i ) Mdel ( a [ j ], a [ i ]); } }","title":"\u524d\u7f00\u548c\u4e0e\u53cd\u6f14"},{"location":"Math/number%20theory/pollardrho/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 mt19937_64 rnd ( time ( 0 ) ^ ( ull )( new char )); #define rd(l,r) ((l)+rnd()%((int)((r)-(l)+1))) inline int mul ( int x , int y , int z ) { int a = x * (( ld ) y / z ), b = x * y - a * z ; if ( b < 0 ) b += z ; if ( b >= z ) b -= z ; return b ; } inline int add ( int x , int y , int z ){ return x + y >= z ? x + y - z : x + y ;} inline int power ( int x , int y , int z ) { int s = 1 ; for (; y ; y >>= 1 , x = mul ( x , x , z )) if ( y & 1 ) s = mul ( s , x , z ); return s ; } inline bool chk ( int n ) { if ( n < 3 || n % 2 == 0 ) return n == 2 ; int u = n -1 , t = 0 ; while ( u % 2 == 0 ) u /= 2 , ++ t ; for ( int i = 0 , s , a , v ; i < 8 ; ++ i ) { a = rd ( 2 , n -1 ), v = power ( a , u , n ); if ( v == 1 ) continue ; for ( s = 0 ; s < t ; ++ s ) { if ( v == n -1 ) break ; v = mul ( v , v , n ); } if ( s == t ) return 0 ; } return 1 ; } #define nx(a) add(mul(a,a,n),c,n) inline int gcd ( int a , int b ) { int az = __builtin_ctzll ( a ), bz = __builtin_ctzll ( b ); int z = min ( az , bz ), tmp ; b >>= bz ; while ( a ) a >>= az , tmp = a - b , az = __builtin_ctzll ( tmp ), b = min ( a , b ), a = abs ( tmp ); return b << z ; } int calc ( int n ) { if ( n == 4 ) return 2 ; int x = rd ( 3 , n -1 ), y = x , c = rd ( 3 , n -1 ), d = 1 ; x = nx ( x ), y = nx ( nx ( y )); for ( int lim = 1 ; x != y ; lim = min ( 128l l , lim << 1 )) { int cnt = 1 ; for ( int i = 0 ; i < lim ; ++ i ) { int tmp = mul ( cnt , abs ( x - y ), n ); if ( ! tmp ) break ; cnt = tmp , x = nx ( x ), y = nx ( nx ( y )); } d = gcd ( cnt , n ); if ( d > 1 ) return d ; } return n ; } vi ve ; void dfs ( int n ) { if ( n == 1 ) return ; int d = calc ( n ), d2 ; while ( d == n ) d = calc ( n ); d2 = n / d ; if ( chk ( d )) ve . eb ( d ); else dfs ( d ); if ( chk ( d2 )) ve . eb ( d2 ); else dfs ( d2 ); }","title":"Pollard-Rho"},{"location":"Math/number%20theory/sieve/dusieve/","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 unordered_map < int , ll > phi ; unordered_map < int , int > mu ; ll PHI [ 20000001 ]; int MU [ 20000001 ], prime [ 10000001 ], cnt , T , n ; bool v [ 20000001 ]; inline int read () { int ans = 0 ; char ch = getchar (); while (( ch > '9' ) || ( ch < '0' )) ch = getchar (); while (( ch >= '0' ) && ( ch <= '9' )) ans = ans * 10 + ch - '0' , ch = getchar (); return ans ; } ll askphi ( int k ) { if ( k <= 20000000 ) return PHI [ k ]; if ( phi [ k ]) return phi [ k ]; ll sum = k * ( k + 1 ) / 2 ; for ( int l = 2 , r ; l <= k ; l = r + 1 ) r = k / ( k / l ), sum -= ( r - l + 1 ) * askphi ( k / l ); return phi [ k ] = sum ; } int askmu ( int k ) { if ( k <= 20000000 ) return MU [ k ]; if ( mu [ k ]) return mu [ k ]; int sum = 1 ; for ( int l = 2 , r ; l <= k ; l = r + 1 ) r = k / ( k / l ), sum -= ( r - l + 1 ) * askmu ( k / l ); return mu [ k ] = sum ; } inline void sieve () { MU [ 1 ] = 1 , PHI [ 1 ] = 1 ; for ( int i = 2 ; i <= 20000000 ; ++ i ) { if ( ! v [ i ]) prime [ ++ cnt ] = i , PHI [ i ] = i -1 , MU [ i ] = -1 ; for ( int j = 1 ; j <= cnt ; ++ j ) { if ( i * prime [ j ] > 20000000 ) break ; v [ prime [ j ] * i ] = 1 ; if ( i % prime [ j ] == 0 ){ PHI [ i * prime [ j ]] = PHI [ i ] * prime [ j ], MU [ i * prime [ j ]] = 0 ; break ;} PHI [ prime [ j ] * i ] = PHI [ i ] * ( prime [ j ] -1 ), MU [ i * prime [ j ]] =- MU [ i ]; } PHI [ i ] += PHI [ i -1 ], MU [ i ] += MU [ i -1 ]; } }","title":"Dusieve"},{"location":"Math/number%20theory/sieve/min25sieve/","text":"\u7b5b\u7684\u662f \\(f(p^k)=p^k(p^k-1)\\) \u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 ll n , w [ 300010 ], g1 [ 300010 ], g2 [ 300010 ], sum1 [ 300010 ], sum2 [ 300010 ], pr [ 300010 ]; int N , m , cnt , id1 [ 300010 ], id2 [ 300010 ], iv6 ; bool v [ 300010 ]; inline void preSieve () { for ( int i = 2 ; i <= N ; ++ i ) { if ( ! v [ i ]) pr [ ++ cnt ] = i ; for ( int j = 1 ; j <= cnt && pr [ j ] * i <= N ; ++ j ) { v [ pr [ j ] * i ] = 1 ; if ( i % pr [ j ] == 0 ) break ;} } for ( int i = 1 ; i <= cnt ; ++ i ) { sum1 [ i ] = Cadd ( sum1 [ i -1 ], pr [ i ]); sum2 [ i ] = ( sum2 [ i -1 ] + 1l l * pr [ i ] * pr [ i ]) % MOD ; } } inline int f1 ( ll x ){ x %= MOD ; return x * ( x + 1 ) / 2 % MOD ;} inline int f2 ( ll x ){ x %= MOD ; return x * ( x + 1 ) % MOD * ( 2 * x + 1 ) % MOD * iv6 % MOD ;} inline int getid ( ll x ){ return x <= N ? id1 [ x ] : id2 [ n / x ];} ll S ( ll x , int j ) { if ( pr [ j ] > x ) return 0 ; ll ans = Cdel ( Cdel ( g2 [ getid ( x )], g1 [ getid ( x )]), Cdel ( sum2 [ j ], sum1 [ j ])); for ( int i = j + 1 ; i <= cnt && pr [ i ] * pr [ j ] <= x ; ++ i ) { for ( ll e = 1 , sp = pr [ i ]; sp <= x ; sp *= pr [ i ], ++ e ) ans = ( ans + sp % MOD * ( sp % MOD -1 ) % MOD * ( S ( x / sp , i ) + ( e > 1 ))) % MOD ; } return ans ; } inline ll sieve () { N = sqrt ( n ), preSieve (), iv6 = power ( 6 , MOD -2 ); for ( ll l = 1 , r ; l <= n ; l = r + 1 ) { r = n / ( n / l ), w [ ++ m ] = n / l ; g1 [ m ] = f1 ( w [ m ]) -1 , g2 [ m ] = f2 ( w [ m ]) -1 ; if ( w [ m ] <= N ) id1 [ w [ m ]] = m ; else id2 [ n / w [ m ]] = m ; } for ( int i = 1 ; i <= cnt ; ++ i ) { for ( int j = 1 ; j <= m && pr [ i ] * pr [ i ] <= w [ j ]; ++ j ) { g1 [ j ] = (( g1 [ j ] -1ll * pr [ i ] * ( g1 [ getid ( w [ j ] / pr [ i ])] - sum1 [ i -1 ])) % MOD + MOD ) % MOD ; g2 [ j ] = (( g2 [ j ] -1ll * pr [ i ] * pr [ i ] % MOD * ( g2 [ getid ( w [ j ] / pr [ i ])] - sum2 [ i -1 ])) % MOD + MOD ) % MOD ; } } return S ( n , 0 ) + 1 ; }","title":"Min25sieve"},{"location":"%E7%BC%BA%E7%9C%81%E6%BA%90/%E7%BC%BA%E7%9C%81%E6%BA%90/","text":"\u7f16\u8bd1\u9009\u9879\uff1a -lm -Wall -Wl,--stack=10240000 -std=c++14 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <bits/stdc++.h> #define ull unsigned long long #define ui unsigned int #define ld long double #define ll long long #define lll __int128 #define fi first #define se second #define e emplace #define eb emplace_back #define db double #define ef emplace_front #define pii pair<int,int> #define pll pair<ll,ll> #define vi vector<int> #define vp vector<pii> #define mp make_pair //#define LOCALJUDGE #define int ll bool ST ; static const ll MOD = 1e9 + 7 , Phi = 998244352 , inv2 = 499122177 , Root = 3 , iRoot = 332748118 ; static const ll inf = 1073741823 , INF = 4557430888798830399 ; static const ld eps = 1e-11 , pi = 3.1415926535 ; char in [ 1 << 20 ], * p1 = in , * p2 = in ; using namespace std ; //#define getchar() (p1==p2&&(p2=(p1=in)+fread(in,1,1<<20,stdin),p1==p2)?EOF:*p1++) struct tup { int x , y , z ; tup ( int X = 0 , int Y = 0 , int Z = 0 ){ x = X , y = Y , z = Z ;}}; namespace FastIO { template < typename T > inline void write ( T x , char ch = ' ' ) { if ( is_same < char , T >:: value ) putchar ( x ); else { if ( x < 0 ) x =- x , putchar ( '-' ); static char st [ 25 ]; int top = 0 ; do { st [ top ++ ] = x % 10 + '0' , x /= 10 ;} while ( x ); while ( top ) putchar ( st [ -- top ]); } ch != '~' ? putchar ( ch ) : 0 ; } inline void write ( const char * x , char ch = ' ' ) { for ( int i = 0 ; x [ i ] != '\\0' ; ++ i ) putchar ( x [ i ]); ch != '~' ? putchar ( ch ) : 0 ; } inline void read ( char & s ){ do s = getchar (); while ( s == '\\n' || s == ' ' );} inline void read ( char s []) { int len = 0 ; char st ; do st = getchar (); while ( st == '\\n' || st == ' ' ); s [ ++ len ] = st , st = getchar (); while ( st != '\\n' && st != ' ' && st != '\\r' ) s [ ++ len ] = st , st = getchar (); s [ ++ len ] = '\\0' ; } template < typename T > inline void read ( T & s ) { s = 0 ; char ch = getchar (); while (( ch > '9' || ch < '0' ) && ch != '-' ) ch = getchar (); bool tf = ( ch == '-' ) && ( ch = getchar ()); while (( ch >= '0' ) && ( ch <= '9' )) s = ( s << 1 ) + ( s << 3 ) + ch - '0' , ch = getchar (); s = ( tf ?- s : s ); } template < typename T1 , typename T2 > inline void read ( pair < T1 , T2 > & s ){ read ( s . fi ), read ( s . se );} template < typename T , typename ... Args > inline void write ( T x , Args ... args ){ write ( x , '~' ), write ( args ...);} template < typename T , typename ... Args > inline void read ( T & x , Args & ... args ){ read ( x ), read ( args ...);} } using namespace FastIO ; namespace MTool { inline int Cadd ( int a , int b ){ return ( ll ) a + b >= MOD ? ( ll ) a + b - MOD : a + b ;} inline int Cdel ( int a , int b ){ return a - b < 0 ? a - b + MOD : a - b ;} inline int Cmul ( int a , int b ){ return 1l l * a * b % MOD ;} inline int sqr ( int a ){ return 1l l * a * a % MOD ;} inline void Madd ( int & a , int b ){ a = (( ll ) a + b >= MOD ? ( ll ) a + b - MOD : a + b );} inline void Mdel ( int & a , int b ){ a = ( a - b < 0 ? a - b + MOD : a - b );} inline void Mmul ( int & a , int b ){ a = 1l l * a * b % MOD ;} template < typename T > inline bool Mmax ( T & a , T b ){ return a < b ? a = b , 1 : 0 ;} template < typename T > inline bool Mmin ( T & a , T b ){ return a > b ? a = b , 1 : 0 ;} template < typename ... Args > inline void Madd ( int & a , int b , Args ... args ){ Madd ( a , b ), Madd ( a , args ...);} template < typename ... Args > inline void Mmul ( int & a , int b , Args ... args ){ Mmul ( a , b ), Mmul ( a , args ...);} template < typename ... Args > inline void Mdel ( int & a , int b , Args ... args ){ Mdel ( a , b ), Mdel ( a , args ...);} template < typename ... Args > inline int Cadd ( int a , int b , Args ... args ){ return Cadd ( Cadd ( a , b ), args ...);} template < typename ... Args > inline int Cmul ( int a , int b , Args ... args ){ return Cmul ( Cmul ( a , b ), args ...);} template < typename ... Args > inline int Cdel ( int a , int b , Args ... args ){ return Cdel ( Cdel ( a , b ), args ...);} template < typename ... Args , typename T > inline bool Mmax ( T & a , T b , Args ... args ){ return Mmax ( a , b ) | Mmax ( a , args ...);} template < typename ... Args , typename T > inline bool Mmin ( T & a , T b , Args ... args ){ return Mmin ( a , b ) | Mmin ( a , args ...);} inline int power ( int x , int y ){ int s = 1 ; for (; y ; y >>= 1 , Mmul ( x , x )) if ( y & 1 ) Mmul ( s , x ); return s ;} } using namespace MTool ; namespace WrongAnswer_90 { inline void mian () { } } bool ED ; signed main () { #ifdef LOCALJUDGE freopen ( \"1.in\" , \"r\" , stdin ); freopen ( \"1.out\" , \"w\" , stdout ); #endif double st = clock (); WrongAnswer_90 :: mian (); double ed = clock (); #ifndef LOCALJUDGE cerr << endl ; #endif cerr << \"Time: \" << ed - st << \" ms \\n \" ; #ifdef LOCALJUDGE cerr << \" \" ; #endif cerr << \"Memory: \" << abs ( & ST -& ED ) / 1024.0 / 1024.0 << \" MB \\n \" ; return 0 ; }","title":"\u7f3a\u7701\u6e90"}]}