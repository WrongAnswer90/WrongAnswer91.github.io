{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u8fd9\u91cc\u662f WA90 \u7684\u4ee3\u7801\u4ed3\u5e93\uff0c\u90e8\u5206\u6a21\u677f\u9700\u8981\u642d\u914d \u7f3a\u7701\u6e90 \u4f7f\u7528 QQ\uff1a2609493041 \u6b22\u8fce\u8054\u7cfb\u3002","title":"Home"},{"location":"Poly/Poly/","text":"\u611f\u89c9\u5e38\u6570\u8fd8\u7b97\u6bd4\u8f83\u4f18\u79c0 QwQ\u3002\u4ee5\u4e0b\u6570\u636e\u8303\u56f4\u9664\u4e86 FFT \u5747\u662f \\(10^5\\) \u3002 FFT( \\(10^6\\) ): \\(270\\text{ms}\\) \u6c42\u9006: \\(33\\text{ms}\\) \u5f00\u6839: \\(53\\text{ms}\\) \u5bf9\u6570\u51fd\u6570: \\(50\\text{ms}\\) \u6307\u6570\u51fd\u6570: \\(175\\text{ms}\\) \uff08\u592a\u62c9\u4e86\uff09 \u9664\u6cd5\uff08\u53d6\u6a21\uff09: \\(50\\text{ms}\\) \u5e42\u51fd\u6570: \\(320\\text{ms}\\) \uff08\u592a\u62c9\u4e86\uff09 \u6ce8\u610f\u66f4\u6539 MAXN\u3002\u4f7f\u7528\u524d\u8981\u8c03\u7528 init() \u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 namespace Poly { const int MAXN = 200000 ; int Shape , Invn [ MAXN + 10 ], R [ MAXN * 4 + 10 ], Prt [ MAXN * 4 ]; inline void init () { Invn [ 0 ] = 1 ; for ( int i = 1 ; i <= MAXN ; ++ i ) Invn [ i ] = Cmul ( Invn [ i -1 ], i ); int tmp = power ( Invn [ MAXN ], MOD -2 ); for ( int i = MAXN ; i >= 1 ; -- i ) Invn [ i ] = Cmul ( tmp , Invn [ i -1 ]), Mmul ( tmp , i ); } inline int inv ( int x ){ return x <= MAXN ? Invn [ x ] : power ( x , MOD -2 );} inline void NTT ( vi & A , int n , int opt ) { static ull B [ MAXN * 4 + 10 ], iv = power ( n , MOD -2 ); A . resize ( n ); for ( int i = 0 ; i < n ; ++ i ) B [ i ] = A [ R [ i ]]; for ( int mid = 1 ; mid < n ; mid <<= 1 ) { for ( int j = 0 ; j < n ; j += mid << 1 ) { for ( int k = j ; k < j + mid ; ++ k ) { ull x = B [ k ], y = Prt [ mid + k - j ] * B [ k + mid ] % MOD ; B [ k ] = x + y , B [ k + mid ] = x + MOD - y ; } } } if ( opt ) for ( int i = 0 ; i < n ; ++ i ) A [ i ] = B [ i ] % MOD ; else { reverse ( B + 1 , B + n ); for ( int i = 0 ; i < n ; ++ i ) A [ i ] = Cmul ( B [ i ] % MOD , iv );} } inline void init ( int lim ) { if ( lim == Shape ) return ; int n = lim / 2 ; Shape = lim ; for ( int i = 0 ; i < lim ; ++ i ) R [ i ] = ( R [ i >> 1 ] >> 1 ) | (( i & 1 ) ? n : 0 ); for ( int i = 1 ; i < lim ; i <<= 1 ) { int wm = power ( Root ,( MOD -1 ) / ( i << 1 )); Prt [ i ] = 1 ; for ( int j = 1 ; j < i ; ++ j ) Prt [ i + j ] = Cmul ( Prt [ i + j -1 ], wm ); } } inline vi del ( vi A , vi B , int N = -1 ) { if ( ~ N ) A . resize ( N + 1 ), B . resize ( N + 1 ); int n = A . size () -1 ; for ( int i = 0 ; i <= n ; ++ i ) Mdel ( A [ i ], B [ i ]); return A ; } inline vi add ( vi A , vi B , int N = -1 ) { if ( ~ N ) A . resize ( N + 1 ), B . resize ( N + 1 ); int n = A . size () -1 ; for ( int i = 0 ; i <= n ; ++ i ) Madd ( A [ i ], B [ i ]); return A ; } inline vi mul ( vi A , int k , int N = -1 ) { if ( ~ N ) A . resize ( N + 1 ); int n = A . size () -1 ; for ( int i = 0 ; i <= n ; ++ i ) Mmul ( A [ i ], k ); return A ; } inline vi inte ( vi A , int N = -1 ) { if ( ~ N ) A . resize ( N + 1 ); int n = A . size (); A . resize ( n + 1 ); for ( int i = n ; i > 0 ; -- i ) A [ i ] = Cmul ( A [ i -1 ], inv ( i )); return A [ 0 ] = 0 , A ; } inline vi der ( vi A , int N = -1 ) { if ( ~ N ) A . resize ( N + 1 ); int n = A . size () -2 ; for ( int i = 0 ; i <= n ; ++ i ) A [ i ] = Cmul ( A [ i + 1 ], i + 1 ); return A . resize ( n + 1 ), A ; } inline vi FFT ( vi A , vi B , int N1 = -1 , int N2 = -1 ) { if ( N1 != -1 ) A . resize ( N1 + 1 ); if ( N2 != -1 ) B . resize ( N2 + 1 ); int n = A . size () -1 , m = B . size () -1 , N = 1 , len = 0 ; while ( N <= n + m ) N <<= 1 , ++ len ; init ( N ), NTT ( A , N , 1 ), NTT ( B , N , 1 ); for ( int i = 0 ; i < N ; ++ i ) A [ i ] = Cmul ( A [ i ], B [ i ]); return NTT ( A , N , 0 ), A . resize ( n + m + 1 ), A ; } inline vi inv ( vi A , int N = -1 ) { if ( N != -1 ) A . resize ( N + 1 ); vi B = {( int ) power ( A [ 0 ], MOD -2 )}; int n = A . size () -1 , nn = n ; for ( n = 1 ; n <= nn + 1 ; n <<= 1 ) { vi TB = B , C ( n * 2 ); init ( n << 1 ); copy ( A . begin (), A . begin () + min ( nn + 1 , 2 * n ), C . begin ()); NTT ( C , n << 1 , 1 ), NTT ( B , n << 1 , 1 ); for ( int i = 0 ; i < ( n << 1 ); ++ i ) C [ i ] = 1l l * C [ i ] * B [ i ] % MOD ; NTT ( C , n << 1 , 0 ); C . resize ( n << 1 ); fill ( C . begin (), C . begin () + n , 0 ), NTT ( C , n << 1 , 1 ); for ( int i = 0 ; i < ( n << 1 ); ++ i ) B [ i ] = 1l l * B [ i ] * ( MOD - C [ i ]) % MOD ; NTT ( B , n << 1 , 0 ); B . resize ( n << 1 ), move ( TB . begin (), TB . end (), B . begin ()); } return B . resize ( nn + 1 ), B ; } inline vi ln ( vi A , int N = -1 ){ return inte ( FFT ( der ( A , N ), inv ( A , N )));} inline vi exp ( vi A , int N = -1 ) { if ( ~ N ) A . resize ( N + 1 ); int m = A . size () -1 ; static vi B , C ; B . clear (), C . clear (), B . eb ( 1 ); for ( int n = 2 ; n <= m ; n <<= 1 ) B . resize ( n + 1 ), C = del ( A , ln ( B ), n ), Madd ( C [ 0 ], 1 ), B = FFT ( B , C , n , n ); C = del ( A , ln ( B ), m ), Madd ( C [ 0 ], 1 ); B . resize ( m + 1 ), C . resize ( m + 1 ); B = FFT ( B , C , m , m ), B . resize ( m + 1 ); return B ; } inline vi div ( vi A , vi B , int N1 = -1 , int N2 = -1 ) { if ( ~ N1 ) A . resize ( N1 + 1 ); if ( ~ N2 ) B . resize ( N2 + 1 ); int n = A . size () -1 , m = B . size () -1 ; reverse ( A . begin (), A . end ()), reverse ( B . begin (), B . end ()); A = FFT ( A , inv ( B , n - m + 1 )), A . resize ( n - m + 1 ), reverse ( A . begin (), A . end ()); return A ; } }","title":"Poly"},{"location":"%E7%BC%BA%E7%9C%81%E6%BA%90/%E7%BC%BA%E7%9C%81%E6%BA%90/","text":"\u7f16\u8bd1\u9009\u9879\uff1a -lm -Wall -Wl,--stack=10240000 -std=c++14 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <bits/stdc++.h> #define ull unsigned long long #define ui unsigned int #define ld long double #define ll long long #define lll __int128 #define fi first #define se second #define e emplace #define eb emplace_back #define db double #define ef emplace_front #define pii pair<int,int> #define pll pair<ll,ll> #define vi vector<int> #define vp vector<pii> #define mp make_pair //#define LOCALJUDGE #define int ll bool ST ; static const ll MOD = 1e9 + 7 , Phi = 998244352 , inv2 = 499122177 , Root = 3 , iRoot = 332748118 ; static const ll inf = 1073741823 , INF = 4557430888798830399 ; static const ld eps = 1e-11 , pi = 3.1415926535 ; char in [ 1 << 20 ], * p1 = in , * p2 = in ; using namespace std ; //#define getchar() (p1==p2&&(p2=(p1=in)+fread(in,1,1<<20,stdin),p1==p2)?EOF:*p1++) struct tup { int x , y , z ; tup ( int X = 0 , int Y = 0 , int Z = 0 ){ x = X , y = Y , z = Z ;}}; namespace FastIO { template < typename T > inline void write ( T x , char ch = ' ' ) { if ( is_same < char , T >:: value ) putchar ( x ); else { if ( x < 0 ) x =- x , putchar ( '-' ); static char st [ 25 ]; int top = 0 ; do { st [ top ++ ] = x % 10 + '0' , x /= 10 ;} while ( x ); while ( top ) putchar ( st [ -- top ]); } ch != '~' ? putchar ( ch ) : 0 ; } inline void write ( const char * x , char ch = ' ' ) { for ( int i = 0 ; x [ i ] != '\\0' ; ++ i ) putchar ( x [ i ]); ch != '~' ? putchar ( ch ) : 0 ; } inline void read ( char & s ){ do s = getchar (); while ( s == '\\n' || s == ' ' );} inline void read ( char s []) { int len = 0 ; char st ; do st = getchar (); while ( st == '\\n' || st == ' ' ); s [ ++ len ] = st , st = getchar (); while ( st != '\\n' && st != ' ' && st != '\\r' ) s [ ++ len ] = st , st = getchar (); s [ ++ len ] = '\\0' ; } template < typename T > inline void read ( T & s ) { s = 0 ; char ch = getchar (); while (( ch > '9' || ch < '0' ) && ch != '-' ) ch = getchar (); bool tf = ( ch == '-' ) && ( ch = getchar ()); while (( ch >= '0' ) && ( ch <= '9' )) s = ( s << 1 ) + ( s << 3 ) + ch - '0' , ch = getchar (); s = ( tf ?- s : s ); } template < typename T1 , typename T2 > inline void read ( pair < T1 , T2 > & s ){ read ( s . fi ), read ( s . se );} template < typename T , typename ... Args > inline void write ( T x , Args ... args ){ write ( x , '~' ), write ( args ...);} template < typename T , typename ... Args > inline void read ( T & x , Args & ... args ){ read ( x ), read ( args ...);} } using namespace FastIO ; namespace MTool { inline int Cadd ( int a , int b ){ return ( ll ) a + b >= MOD ? ( ll ) a + b - MOD : a + b ;} inline int Cdel ( int a , int b ){ return a - b < 0 ? a - b + MOD : a - b ;} inline int Cmul ( int a , int b ){ return 1l l * a * b % MOD ;} inline int sqr ( int a ){ return 1l l * a * a % MOD ;} inline void Madd ( int & a , int b ){ a = (( ll ) a + b >= MOD ? ( ll ) a + b - MOD : a + b );} inline void Mdel ( int & a , int b ){ a = ( a - b < 0 ? a - b + MOD : a - b );} inline void Mmul ( int & a , int b ){ a = 1l l * a * b % MOD ;} template < typename T > inline bool Mmax ( T & a , T b ){ return a < b ? a = b , 1 : 0 ;} template < typename T > inline bool Mmin ( T & a , T b ){ return a > b ? a = b , 1 : 0 ;} template < typename ... Args > inline void Madd ( int & a , int b , Args ... args ){ Madd ( a , b ), Madd ( a , args ...);} template < typename ... Args > inline void Mmul ( int & a , int b , Args ... args ){ Mmul ( a , b ), Mmul ( a , args ...);} template < typename ... Args > inline void Mdel ( int & a , int b , Args ... args ){ Mdel ( a , b ), Mdel ( a , args ...);} template < typename ... Args > inline int Cadd ( int a , int b , Args ... args ){ return Cadd ( Cadd ( a , b ), args ...);} template < typename ... Args > inline int Cmul ( int a , int b , Args ... args ){ return Cmul ( Cmul ( a , b ), args ...);} template < typename ... Args > inline int Cdel ( int a , int b , Args ... args ){ return Cdel ( Cdel ( a , b ), args ...);} template < typename ... Args , typename T > inline bool Mmax ( T & a , T b , Args ... args ){ return Mmax ( a , b ) | Mmax ( a , args ...);} template < typename ... Args , typename T > inline bool Mmin ( T & a , T b , Args ... args ){ return Mmin ( a , b ) | Mmin ( a , args ...);} inline int power ( int x , int y ){ int s = 1 ; for (; y ; y >>= 1 , Mmul ( x , x )) if ( y & 1 ) Mmul ( s , x ); return s ;} } using namespace MTool ; namespace WrongAnswer_90 { inline void mian () { } } bool ED ; signed main () { #ifdef LOCALJUDGE freopen ( \"1.in\" , \"r\" , stdin ); freopen ( \"1.out\" , \"w\" , stdout ); #endif double st = clock (); WrongAnswer_90 :: mian (); double ed = clock (); #ifndef LOCALJUDGE cerr << endl ; #endif cerr << \"Time: \" << ed - st << \" ms \\n \" ; #ifdef LOCALJUDGE cerr << \" \" ; #endif cerr << \"Memory: \" << abs ( & ST -& ED ) / 1024.0 / 1024.0 << \" MB \\n \" ; return 0 ; }","title":"\u7f3a\u7701\u6e90"}]}