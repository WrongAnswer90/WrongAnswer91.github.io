# LCA

$\mathcal O(n\log n)-O(1)$

瓶颈在于 ST 表，也可用 $O(n)-O(1)$ RMQ。

```cpp
int n,m,tot,cnt,dfn[500010],head[500010],to[1000010],nex[1000010];
inline void add(int x,int y){to[++cnt]=y,nex[cnt]=head[x],head[x]=cnt;}
int F[19][500010];
inline int get(int x,int y){return dfn[x]<dfn[y]?x:y;}
void dfs(int x,int fa)
{
	F[0][dfn[x]=++tot]=fa;
	for(int i=head[x];i;i=nex[i])if(to[i]!=fa)dfs(to[i],x);
}
inline int LCA(int x,int y)
{
	if(x==y)return x;
	if((x=dfn[x])>(y=dfn[y]))swap(x,y);
	int k=__lg(y-x++);
	return get(F[k][x],F[k][y-(1<<k)+1]);
}
inline void prework()
{
	dfs(1,0);
	for(int i=1;i<19;++i)
	{
		for(int j=1;j+(1<<i)-1<=n;++j)
		F[i][j]=get(F[i-1][j],F[i-1][j+(1<<(i-1))]);
	}
}
```

# 连通性

## 圆方树

点数开两倍。

```cpp
int n,m,tot,cnt,num,dfn[500010],low[500010],head[500010],to[2000010],nex[2000010];
vi T[1000010];stack<int> st;
inline void add(int x,int y){to[++cnt]=y,nex[cnt]=head[x],head[x]=cnt;}
void tarjan(int x)
{
	st.e(x),dfn[x]=low[x]=++tot;
	for(int i=head[x];i;i=nex[i])
	{
		if(!dfn[to[i]])
		{
			tarjan(to[i]),Mmin(low[x],low[to[i]]);
			if(low[to[i]]==dfn[x])
			{
				T[++num].eb(x),T[x].eb(num);int y;
				do y=st.top(),st.pop(),T[num].eb(y),T[y].eb(num);while(y!=to[i]);
			}
		}
		else Mmin(low[x],dfn[to[i]]);
	}
}
inline void prework(){num=n;for(int i=1;i<=n;++i)if(!dfn[i])tarjan(i);}
```cpp

## 边双

```cpp
int n,m,cnt=1,tot,num,low[500010],col[500010],dfn[500010],head[500010],to[2000010],nex[2000010];
inline void add(int x,int y){to[++cnt]=y,nex[cnt]=head[x],head[x]=cnt;}
stack<int> st;
vi ve[500010];
void tarjan(int k,int fromi)
{
	dfn[k]=low[k]=++tot,st.e(k);
	for(int i=head[k];i;i=nex[i])
	{
		if(i==(fromi^1))continue;
		if(!dfn[to[i]])tarjan(to[i],i),Mmin(low[k],low[to[i]]);
		else Mmin(low[k],dfn[to[i]]);
	}
	if(low[k]==dfn[k])
	{
		int y;++num;
		do ve[num].eb(y=st.top()),col[y]=num,st.pop();while(y!=k);
	}
}
inline void prework(){for(int i=1;i<=n;++i)if(!dfn[i])tarjan(i,0);}
```

## 强联通

```cpp
int n,m,cnt,num,tot,col[500010],dfn[500010],low[500001],ins[500001],head[500001],to[1000010],nex[1000010];
inline void add(int x,int y){to[++cnt]=y,nex[cnt]=head[x],head[x]=cnt;}
stack<int> st;
queue<int> q;
void tarjan(int k)
{
	st.e(k),ins[k]=1,dfn[k]=low[k]=++tot;
	for(int i=head[k];i;i=nex[i])
	{
		if(!dfn[to[i]])tarjan(to[i]),Mmin(low[k],low[to[i]]);
		else if(ins[to[i]])Mmin(low[k],dfn[to[i]]);
	}
	if(dfn[k]==low[k])
	{
		int y;++num;
		do col[y=st.top()]=num,ins[y]=0,st.pop();while(y!=k);
	}
}
inline void prework(){for(int i=1;i<=n;++i)if(!dfn[i])tarjan(i);}
```

# 流

## 最大流

```cpp
int S,T,cnt=1,head[3050],to[100010],nex[100010],v[100010],d[3050],now[3050];
inline void Add(int x,int y,int z){to[++cnt]=y,v[cnt]=z,nex[cnt]=head[x],head[x]=cnt;}
inline void add(int x,int y,int z){Add(x,y,z),Add(y,x,0);}
inline void clr(){memset(head,0,sizeof(head)),cnt=1;}
inline bool bfs()
{
	queue<int> q;memset(d,0,sizeof(d)),d[S]=1,now[S]=head[S],q.e(S);
	while(!q.empty())
	{
		int nw=q.front();q.pop();
		for(int i=head[nw];i;i=nex[i])if(v[i]&&!d[to[i]])
		{
			d[to[i]]=d[nw]+1,q.e(to[i]),now[to[i]]=head[to[i]];
			if(to[i]==T)return 1;
		}
	}
	return 0;
}
int dinic(int x,int flow)
{
	if(x==T)return flow;
	int rest=flow,t;
	for(int i=now[x];i&&rest;i=nex[i])
	{
		now[x]=i;
		if(d[to[i]]!=d[x]+1||!v[i])continue;
		t=dinic(to[i],min(rest,v[i])),rest-=t;
		if(!t)d[to[i]]=0;
		v[i]-=t,v[i^1]+=t;
	}
	return flow-rest;
}
inline int flow(){int s=0,x;while(bfs())while((x=dinic(S,INF)))s+=x;return s;}
```

## 费用流

```cpp
int S,T,ans,sum,cnt=1,h[5010],d[5010],pre[5010],incf[5010];
int head[5010],to[100010],nex[100010],v[100010],c[100010];
inline void Add(int x,int y,int z,int t){to[++cnt]=y,v[cnt]=z,c[cnt]=t,nex[cnt]=head[x],head[x]=cnt;}
inline void add(int x,int y,int z,int t){Add(x,y,z,t),Add(y,x,0,-t);}
inline void clr(){memset(head,0,sizeof(head)),cnt=1;}
priority_queue<pii> q;
bool vis[5010];
inline bool dij()
{
	for(int i=1;i<=T;++i){if(vis[i])h[i]+=d[i];d[i]=inf;}
	q.e(mp(0,S)),memset(incf,0,sizeof(incf)),memset(vis,0,sizeof(vis)),d[S]=0,incf[S]=inf;
	while(!q.empty())
	{
		int now=q.top().se;q.pop();
		if(vis[now])continue;vis[now]=1;
		for(int i=head[now];i;i=nex[i])
		{
			if(v[i]&&Mmin(d[to[i]],d[now]-h[to[i]]+h[now]+c[i]))
			q.e(mp(-d[to[i]],to[i])),incf[to[i]]=min(v[i],incf[now]),pre[to[i]]=i;
		}
	}
	return incf[T];
}
inline void update()
{
	int now=T;ans+=incf[T]*(d[T]-h[S]+h[T]),sum+=incf[T];
	while(now!=S)v[pre[now]]-=incf[T],v[pre[now]^1]+=incf[T],now=to[pre[now]^1];
}
inline void flow(){while(dij())update();}

```