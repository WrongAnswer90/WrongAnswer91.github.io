{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u8fd9\u91cc\u662f WA90 \u7684\u4ee3\u7801\u4ed3\u5e93\uff0c\u90e8\u5206\u6a21\u677f\u9700\u8981\u642d\u914d \u7f3a\u7701\u6e90 \u4f7f\u7528 QQ\uff1a2609493041 \u6b22\u8fce\u8054\u7cfb\u3002","title":"Home"},{"location":"%E5%9B%BE%E8%AE%BA/","text":"LCA \u00b6 \\(\\mathcal O(n\\log n)-O(1)\\) \u74f6\u9888\u5728\u4e8e ST \u8868\uff0c\u4e5f\u53ef\u7528 \\(O(n)-O(1)\\) RMQ\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int n , m , tot , cnt , dfn [ 500010 ], head [ 500010 ], to [ 1000010 ], nex [ 1000010 ]; inline void add ( int x , int y ){ to [ ++ cnt ] = y , nex [ cnt ] = head [ x ], head [ x ] = cnt ;} int F [ 19 ][ 500010 ]; inline int get ( int x , int y ){ return dfn [ x ] < dfn [ y ] ? x : y ;} void dfs ( int x , int fa ) { F [ 0 ][ dfn [ x ] =++ tot ] = fa ; for ( int i = head [ x ]; i ; i = nex [ i ]) if ( to [ i ] != fa ) dfs ( to [ i ], x ); } inline int LCA ( int x , int y ) { if ( x == y ) return x ; if (( x = dfn [ x ]) > ( y = dfn [ y ])) swap ( x , y ); int k = __lg ( y - x ++ ); return get ( F [ k ][ x ], F [ k ][ y - ( 1 << k ) + 1 ]); } inline void prework () { dfs ( 1 , 0 ); for ( int i = 1 ; i < 19 ; ++ i ) { for ( int j = 1 ; j + ( 1 << i ) -1 <= n ; ++ j ) F [ i ][ j ] = get ( F [ i -1 ][ j ], F [ i -1 ][ j + ( 1 << ( i -1 ))]); } } \u8fde\u901a\u6027 \u00b6 \u5706\u65b9\u6811 \u00b6 \u70b9\u6570\u5f00\u4e24\u500d\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 int n , m , tot , cnt , num , dfn [ 500010 ], low [ 500010 ], head [ 500010 ], to [ 2000010 ], nex [ 2000010 ]; vi T [ 1000010 ]; stack < int > st ; inline void add ( int x , int y ){ to [ ++ cnt ] = y , nex [ cnt ] = head [ x ], head [ x ] = cnt ;} void tarjan ( int x ) { st . e ( x ), dfn [ x ] = low [ x ] =++ tot ; for ( int i = head [ x ]; i ; i = nex [ i ]) { if ( ! dfn [ to [ i ]]) { tarjan ( to [ i ]), Mmin ( low [ x ], low [ to [ i ]]); if ( low [ to [ i ]] == dfn [ x ]) { T [ ++ num ]. eb ( x ), T [ x ]. eb ( num ); int y ; do y = st . top (), st . pop (), T [ num ]. eb ( y ), T [ y ]. eb ( num ); while ( y != to [ i ]); } } else Mmin ( low [ x ], dfn [ to [ i ]]); } } inline void prework (){ num = n ; for ( int i = 1 ; i <= n ; ++ i ) if ( ! dfn [ i ]) tarjan ( i );} ``` cpp ## \u8fb9\u53cc ``` cpp int n , m , cnt = 1 , tot , num , low [ 500010 ], col [ 500010 ], dfn [ 500010 ], head [ 500010 ], to [ 2000010 ], nex [ 2000010 ]; inline void add ( int x , int y ){ to [ ++ cnt ] = y , nex [ cnt ] = head [ x ], head [ x ] = cnt ;} stack < int > st ; vi ve [ 500010 ]; void tarjan ( int k , int fromi ) { dfn [ k ] = low [ k ] =++ tot , st . e ( k ); for ( int i = head [ k ]; i ; i = nex [ i ]) { if ( i == ( fromi ^ 1 )) continue ; if ( ! dfn [ to [ i ]]) tarjan ( to [ i ], i ), Mmin ( low [ k ], low [ to [ i ]]); else Mmin ( low [ k ], dfn [ to [ i ]]); } if ( low [ k ] == dfn [ k ]) { int y ; ++ num ; do ve [ num ]. eb ( y = st . top ()), col [ y ] = num , st . pop (); while ( y != k ); } } inline void prework (){ for ( int i = 1 ; i <= n ; ++ i ) if ( ! dfn [ i ]) tarjan ( i , 0 );} \u5f3a\u8054\u901a \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int n , m , cnt , num , tot , col [ 500010 ], dfn [ 500010 ], low [ 500001 ], ins [ 500001 ], head [ 500001 ], to [ 1000010 ], nex [ 1000010 ]; inline void add ( int x , int y ){ to [ ++ cnt ] = y , nex [ cnt ] = head [ x ], head [ x ] = cnt ;} stack < int > st ; queue < int > q ; void tarjan ( int k ) { st . e ( k ), ins [ k ] = 1 , dfn [ k ] = low [ k ] =++ tot ; for ( int i = head [ k ]; i ; i = nex [ i ]) { if ( ! dfn [ to [ i ]]) tarjan ( to [ i ]), Mmin ( low [ k ], low [ to [ i ]]); else if ( ins [ to [ i ]]) Mmin ( low [ k ], dfn [ to [ i ]]); } if ( dfn [ k ] == low [ k ]) { int y ; ++ num ; do col [ y = st . top ()] = num , ins [ y ] = 0 , st . pop (); while ( y != k ); } } inline void prework (){ for ( int i = 1 ; i <= n ; ++ i ) if ( ! dfn [ i ]) tarjan ( i );} \u6d41 \u00b6 \u6700\u5927\u6d41 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 int S , T , cnt = 1 , head [ 3050 ], to [ 100010 ], nex [ 100010 ], v [ 100010 ], d [ 3050 ], now [ 3050 ]; inline void Add ( int x , int y , int z ){ to [ ++ cnt ] = y , v [ cnt ] = z , nex [ cnt ] = head [ x ], head [ x ] = cnt ;} inline void add ( int x , int y , int z ){ Add ( x , y , z ), Add ( y , x , 0 );} inline void clr (){ memset ( head , 0 , sizeof ( head )), cnt = 1 ;} inline bool bfs () { queue < int > q ; memset ( d , 0 , sizeof ( d )), d [ S ] = 1 , now [ S ] = head [ S ], q . e ( S ); while ( ! q . empty ()) { int nw = q . front (); q . pop (); for ( int i = head [ nw ]; i ; i = nex [ i ]) if ( v [ i ] &&! d [ to [ i ]]) { d [ to [ i ]] = d [ nw ] + 1 , q . e ( to [ i ]), now [ to [ i ]] = head [ to [ i ]]; if ( to [ i ] == T ) return 1 ; } } return 0 ; } int dinic ( int x , int flow ) { if ( x == T ) return flow ; int rest = flow , t ; for ( int i = now [ x ]; i && rest ; i = nex [ i ]) { now [ x ] = i ; if ( d [ to [ i ]] != d [ x ] + 1 ||! v [ i ]) continue ; t = dinic ( to [ i ], min ( rest , v [ i ])), rest -= t ; if ( ! t ) d [ to [ i ]] = 0 ; v [ i ] -= t , v [ i ^ 1 ] += t ; } return flow - rest ; } inline int flow (){ int s = 0 , x ; while ( bfs ()) while (( x = dinic ( S , INF ))) s += x ; return s ;} \u8d39\u7528\u6d41 \u00b6 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 int S , T , ans , sum , cnt = 1 , h [ 5010 ], d [ 5010 ], pre [ 5010 ], incf [ 5010 ]; int head [ 5010 ], to [ 100010 ], nex [ 100010 ], v [ 100010 ], c [ 100010 ]; inline void Add ( int x , int y , int z , int t ){ to [ ++ cnt ] = y , v [ cnt ] = z , c [ cnt ] = t , nex [ cnt ] = head [ x ], head [ x ] = cnt ;} inline void add ( int x , int y , int z , int t ){ Add ( x , y , z , t ), Add ( y , x , 0 , - t );} inline void clr (){ memset ( head , 0 , sizeof ( head )), cnt = 1 ;} priority_queue < pii > q ; bool vis [ 5010 ]; inline bool dij () { for ( int i = 1 ; i <= T ; ++ i ){ if ( vis [ i ]) h [ i ] += d [ i ]; d [ i ] = inf ;} q . e ( mp ( 0 , S )), memset ( incf , 0 , sizeof ( incf )), memset ( vis , 0 , sizeof ( vis )), d [ S ] = 0 , incf [ S ] = inf ; while ( ! q . empty ()) { int now = q . top (). se ; q . pop (); if ( vis [ now ]) continue ; vis [ now ] = 1 ; for ( int i = head [ now ]; i ; i = nex [ i ]) { if ( v [ i ] && Mmin ( d [ to [ i ]], d [ now ] - h [ to [ i ]] + h [ now ] + c [ i ])) q . e ( mp ( - d [ to [ i ]], to [ i ])), incf [ to [ i ]] = min ( v [ i ], incf [ now ]), pre [ to [ i ]] = i ; } } return incf [ T ]; } inline void update () { int now = T ; ans += incf [ T ] * ( d [ T ] - h [ S ] + h [ T ]), sum += incf [ T ]; while ( now != S ) v [ pre [ now ]] -= incf [ T ], v [ pre [ now ] ^ 1 ] += incf [ T ], now = to [ pre [ now ] ^ 1 ]; } inline void flow (){ while ( dij ()) update ();}","title":"LCA"},{"location":"%E5%9B%BE%E8%AE%BA/#lca","text":"\\(\\mathcal O(n\\log n)-O(1)\\) \u74f6\u9888\u5728\u4e8e ST \u8868\uff0c\u4e5f\u53ef\u7528 \\(O(n)-O(1)\\) RMQ\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 int n , m , tot , cnt , dfn [ 500010 ], head [ 500010 ], to [ 1000010 ], nex [ 1000010 ]; inline void add ( int x , int y ){ to [ ++ cnt ] = y , nex [ cnt ] = head [ x ], head [ x ] = cnt ;} int F [ 19 ][ 500010 ]; inline int get ( int x , int y ){ return dfn [ x ] < dfn [ y ] ? x : y ;} void dfs ( int x , int fa ) { F [ 0 ][ dfn [ x ] =++ tot ] = fa ; for ( int i = head [ x ]; i ; i = nex [ i ]) if ( to [ i ] != fa ) dfs ( to [ i ], x ); } inline int LCA ( int x , int y ) { if ( x == y ) return x ; if (( x = dfn [ x ]) > ( y = dfn [ y ])) swap ( x , y ); int k = __lg ( y - x ++ ); return get ( F [ k ][ x ], F [ k ][ y - ( 1 << k ) + 1 ]); } inline void prework () { dfs ( 1 , 0 ); for ( int i = 1 ; i < 19 ; ++ i ) { for ( int j = 1 ; j + ( 1 << i ) -1 <= n ; ++ j ) F [ i ][ j ] = get ( F [ i -1 ][ j ], F [ i -1 ][ j + ( 1 << ( i -1 ))]); } }","title":"LCA"},{"location":"%E5%9B%BE%E8%AE%BA/#_1","text":"","title":"\u8fde\u901a\u6027"},{"location":"%E5%9B%BE%E8%AE%BA/#_2","text":"\u70b9\u6570\u5f00\u4e24\u500d\u3002 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 int n , m , tot , cnt , num , dfn [ 500010 ], low [ 500010 ], head [ 500010 ], to [ 2000010 ], nex [ 2000010 ]; vi T [ 1000010 ]; stack < int > st ; inline void add ( int x , int y ){ to [ ++ cnt ] = y , nex [ cnt ] = head [ x ], head [ x ] = cnt ;} void tarjan ( int x ) { st . e ( x ), dfn [ x ] = low [ x ] =++ tot ; for ( int i = head [ x ]; i ; i = nex [ i ]) { if ( ! dfn [ to [ i ]]) { tarjan ( to [ i ]), Mmin ( low [ x ], low [ to [ i ]]); if ( low [ to [ i ]] == dfn [ x ]) { T [ ++ num ]. eb ( x ), T [ x ]. eb ( num ); int y ; do y = st . top (), st . pop (), T [ num ]. eb ( y ), T [ y ]. eb ( num ); while ( y != to [ i ]); } } else Mmin ( low [ x ], dfn [ to [ i ]]); } } inline void prework (){ num = n ; for ( int i = 1 ; i <= n ; ++ i ) if ( ! dfn [ i ]) tarjan ( i );} ``` cpp ## \u8fb9\u53cc ``` cpp int n , m , cnt = 1 , tot , num , low [ 500010 ], col [ 500010 ], dfn [ 500010 ], head [ 500010 ], to [ 2000010 ], nex [ 2000010 ]; inline void add ( int x , int y ){ to [ ++ cnt ] = y , nex [ cnt ] = head [ x ], head [ x ] = cnt ;} stack < int > st ; vi ve [ 500010 ]; void tarjan ( int k , int fromi ) { dfn [ k ] = low [ k ] =++ tot , st . e ( k ); for ( int i = head [ k ]; i ; i = nex [ i ]) { if ( i == ( fromi ^ 1 )) continue ; if ( ! dfn [ to [ i ]]) tarjan ( to [ i ], i ), Mmin ( low [ k ], low [ to [ i ]]); else Mmin ( low [ k ], dfn [ to [ i ]]); } if ( low [ k ] == dfn [ k ]) { int y ; ++ num ; do ve [ num ]. eb ( y = st . top ()), col [ y ] = num , st . pop (); while ( y != k ); } } inline void prework (){ for ( int i = 1 ; i <= n ; ++ i ) if ( ! dfn [ i ]) tarjan ( i , 0 );}","title":"\u5706\u65b9\u6811"},{"location":"%E5%9B%BE%E8%AE%BA/#_3","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 int n , m , cnt , num , tot , col [ 500010 ], dfn [ 500010 ], low [ 500001 ], ins [ 500001 ], head [ 500001 ], to [ 1000010 ], nex [ 1000010 ]; inline void add ( int x , int y ){ to [ ++ cnt ] = y , nex [ cnt ] = head [ x ], head [ x ] = cnt ;} stack < int > st ; queue < int > q ; void tarjan ( int k ) { st . e ( k ), ins [ k ] = 1 , dfn [ k ] = low [ k ] =++ tot ; for ( int i = head [ k ]; i ; i = nex [ i ]) { if ( ! dfn [ to [ i ]]) tarjan ( to [ i ]), Mmin ( low [ k ], low [ to [ i ]]); else if ( ins [ to [ i ]]) Mmin ( low [ k ], dfn [ to [ i ]]); } if ( dfn [ k ] == low [ k ]) { int y ; ++ num ; do col [ y = st . top ()] = num , ins [ y ] = 0 , st . pop (); while ( y != k ); } } inline void prework (){ for ( int i = 1 ; i <= n ; ++ i ) if ( ! dfn [ i ]) tarjan ( i );}","title":"\u5f3a\u8054\u901a"},{"location":"%E5%9B%BE%E8%AE%BA/#_4","text":"","title":"\u6d41"},{"location":"%E5%9B%BE%E8%AE%BA/#_5","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 int S , T , cnt = 1 , head [ 3050 ], to [ 100010 ], nex [ 100010 ], v [ 100010 ], d [ 3050 ], now [ 3050 ]; inline void Add ( int x , int y , int z ){ to [ ++ cnt ] = y , v [ cnt ] = z , nex [ cnt ] = head [ x ], head [ x ] = cnt ;} inline void add ( int x , int y , int z ){ Add ( x , y , z ), Add ( y , x , 0 );} inline void clr (){ memset ( head , 0 , sizeof ( head )), cnt = 1 ;} inline bool bfs () { queue < int > q ; memset ( d , 0 , sizeof ( d )), d [ S ] = 1 , now [ S ] = head [ S ], q . e ( S ); while ( ! q . empty ()) { int nw = q . front (); q . pop (); for ( int i = head [ nw ]; i ; i = nex [ i ]) if ( v [ i ] &&! d [ to [ i ]]) { d [ to [ i ]] = d [ nw ] + 1 , q . e ( to [ i ]), now [ to [ i ]] = head [ to [ i ]]; if ( to [ i ] == T ) return 1 ; } } return 0 ; } int dinic ( int x , int flow ) { if ( x == T ) return flow ; int rest = flow , t ; for ( int i = now [ x ]; i && rest ; i = nex [ i ]) { now [ x ] = i ; if ( d [ to [ i ]] != d [ x ] + 1 ||! v [ i ]) continue ; t = dinic ( to [ i ], min ( rest , v [ i ])), rest -= t ; if ( ! t ) d [ to [ i ]] = 0 ; v [ i ] -= t , v [ i ^ 1 ] += t ; } return flow - rest ; } inline int flow (){ int s = 0 , x ; while ( bfs ()) while (( x = dinic ( S , INF ))) s += x ; return s ;}","title":"\u6700\u5927\u6d41"},{"location":"%E5%9B%BE%E8%AE%BA/#_6","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 int S , T , ans , sum , cnt = 1 , h [ 5010 ], d [ 5010 ], pre [ 5010 ], incf [ 5010 ]; int head [ 5010 ], to [ 100010 ], nex [ 100010 ], v [ 100010 ], c [ 100010 ]; inline void Add ( int x , int y , int z , int t ){ to [ ++ cnt ] = y , v [ cnt ] = z , c [ cnt ] = t , nex [ cnt ] = head [ x ], head [ x ] = cnt ;} inline void add ( int x , int y , int z , int t ){ Add ( x , y , z , t ), Add ( y , x , 0 , - t );} inline void clr (){ memset ( head , 0 , sizeof ( head )), cnt = 1 ;} priority_queue < pii > q ; bool vis [ 5010 ]; inline bool dij () { for ( int i = 1 ; i <= T ; ++ i ){ if ( vis [ i ]) h [ i ] += d [ i ]; d [ i ] = inf ;} q . e ( mp ( 0 , S )), memset ( incf , 0 , sizeof ( incf )), memset ( vis , 0 , sizeof ( vis )), d [ S ] = 0 , incf [ S ] = inf ; while ( ! q . empty ()) { int now = q . top (). se ; q . pop (); if ( vis [ now ]) continue ; vis [ now ] = 1 ; for ( int i = head [ now ]; i ; i = nex [ i ]) { if ( v [ i ] && Mmin ( d [ to [ i ]], d [ now ] - h [ to [ i ]] + h [ now ] + c [ i ])) q . e ( mp ( - d [ to [ i ]], to [ i ])), incf [ to [ i ]] = min ( v [ i ], incf [ now ]), pre [ to [ i ]] = i ; } } return incf [ T ]; } inline void update () { int now = T ; ans += incf [ T ] * ( d [ T ] - h [ S ] + h [ T ]), sum += incf [ T ]; while ( now != S ) v [ pre [ now ]] -= incf [ T ], v [ pre [ now ] ^ 1 ] += incf [ T ], now = to [ pre [ now ] ^ 1 ]; } inline void flow (){ while ( dij ()) update ();}","title":"\u8d39\u7528\u6d41"},{"location":"%E7%BC%BA%E7%9C%81%E6%BA%90/","text":"\u7f16\u8bd1\u9009\u9879\uff1a -lm -Wall -Wl,--stack=10240000 -std=c++14 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 #include <bits/stdc++.h> #define ull unsigned long long #define ui unsigned int #define ld long double #define ll long long #define lll __int128 #define fi first #define se second #define e emplace #define eb emplace_back #define db double #define ef emplace_front #define pii pair<int,int> #define pll pair<ll,ll> #define vi vector<int> #define vp vector<pii> #define mp make_pair //#define LOCALJUDGE #define int ll bool ST ; static const ll MOD = 1e9 + 7 , Phi = 998244352 , inv2 = 499122177 , Root = 3 , iRoot = 332748118 ; static const ll inf = 1073741823 , INF = 4557430888798830399 ; static const ld eps = 1e-11 , pi = 3.1415926535 ; char in [ 1 << 20 ], * p1 = in , * p2 = in ; using namespace std ; //#define getchar() (p1==p2&&(p2=(p1=in)+fread(in,1,1<<20,stdin),p1==p2)?EOF:*p1++) struct tup { int x , y , z ; tup ( int X = 0 , int Y = 0 , int Z = 0 ){ x = X , y = Y , z = Z ;}}; namespace FastIO { template < typename T > inline void write ( T x , char ch = ' ' ) { if ( is_same < char , T >:: value ) putchar ( x ); else { if ( x < 0 ) x =- x , putchar ( '-' ); static char st [ 25 ]; int top = 0 ; do { st [ top ++ ] = x % 10 + '0' , x /= 10 ;} while ( x ); while ( top ) putchar ( st [ -- top ]); } ch != '~' ? putchar ( ch ) : 0 ; } inline void write ( const char * x , char ch = ' ' ) { for ( int i = 0 ; x [ i ] != '\\0' ; ++ i ) putchar ( x [ i ]); ch != '~' ? putchar ( ch ) : 0 ; } inline void read ( char & s ){ do s = getchar (); while ( s == '\\n' || s == ' ' );} inline void read ( char s []) { int len = 0 ; char st ; do st = getchar (); while ( st == '\\n' || st == ' ' ); s [ ++ len ] = st , st = getchar (); while ( st != '\\n' && st != ' ' && st != '\\r' ) s [ ++ len ] = st , st = getchar (); s [ ++ len ] = '\\0' ; } template < typename T > inline void read ( T & s ) { s = 0 ; char ch = getchar (); while (( ch > '9' || ch < '0' ) && ch != '-' ) ch = getchar (); bool tf = ( ch == '-' ) && ( ch = getchar ()); while (( ch >= '0' ) && ( ch <= '9' )) s = ( s << 1 ) + ( s << 3 ) + ch - '0' , ch = getchar (); s = ( tf ?- s : s ); } template < typename T1 , typename T2 > inline void read ( pair < T1 , T2 > & s ){ read ( s . fi ), read ( s . se );} template < typename T , typename ... Args > inline void write ( T x , Args ... args ){ write ( x , '~' ), write ( args ...);} template < typename T , typename ... Args > inline void read ( T & x , Args & ... args ){ read ( x ), read ( args ...);} } using namespace FastIO ; namespace MTool { inline int Cadd ( int a , int b ){ return ( ll ) a + b >= MOD ? ( ll ) a + b - MOD : a + b ;} inline int Cdel ( int a , int b ){ return a - b < 0 ? a - b + MOD : a - b ;} inline int Cmul ( int a , int b ){ return 1l l * a * b % MOD ;} inline int sqr ( int a ){ return 1l l * a * a % MOD ;} inline void Madd ( int & a , int b ){ a = (( ll ) a + b >= MOD ? ( ll ) a + b - MOD : a + b );} inline void Mdel ( int & a , int b ){ a = ( a - b < 0 ? a - b + MOD : a - b );} inline void Mmul ( int & a , int b ){ a = 1l l * a * b % MOD ;} template < typename T > inline bool Mmax ( T & a , T b ){ return a < b ? a = b , 1 : 0 ;} template < typename T > inline bool Mmin ( T & a , T b ){ return a > b ? a = b , 1 : 0 ;} template < typename ... Args > inline void Madd ( int & a , int b , Args ... args ){ Madd ( a , b ), Madd ( a , args ...);} template < typename ... Args > inline void Mmul ( int & a , int b , Args ... args ){ Mmul ( a , b ), Mmul ( a , args ...);} template < typename ... Args > inline void Mdel ( int & a , int b , Args ... args ){ Mdel ( a , b ), Mdel ( a , args ...);} template < typename ... Args > inline int Cadd ( int a , int b , Args ... args ){ return Cadd ( Cadd ( a , b ), args ...);} template < typename ... Args > inline int Cmul ( int a , int b , Args ... args ){ return Cmul ( Cmul ( a , b ), args ...);} template < typename ... Args > inline int Cdel ( int a , int b , Args ... args ){ return Cdel ( Cdel ( a , b ), args ...);} template < typename ... Args , typename T > inline bool Mmax ( T & a , T b , Args ... args ){ return Mmax ( a , b ) | Mmax ( a , args ...);} template < typename ... Args , typename T > inline bool Mmin ( T & a , T b , Args ... args ){ return Mmin ( a , b ) | Mmin ( a , args ...);} inline int power ( int x , int y ){ int s = 1 ; for (; y ; y >>= 1 , Mmul ( x , x )) if ( y & 1 ) Mmul ( s , x ); return s ;} } using namespace MTool ; namespace WrongAnswer_90 { inline void mian () { } } bool ED ; signed main () { #ifdef LOCALJUDGE freopen ( \"1.in\" , \"r\" , stdin ); freopen ( \"1.out\" , \"w\" , stdout ); #endif double st = clock (); WrongAnswer_90 :: mian (); double ed = clock (); #ifndef LOCALJUDGE cerr << endl ; #endif cerr << \"Time: \" << ed - st << \" ms \\n \" ; #ifdef LOCALJUDGE cerr << \" \" ; #endif cerr << \"Memory: \" << abs ( & ST -& ED ) / 1024.0 / 1024.0 << \" MB \\n \" ; return 0 ; }","title":"\u7f3a\u7701\u6e90"}]}